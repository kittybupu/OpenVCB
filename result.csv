"Source Line","Source","Clockticks","Instructions Retired","CPI Rate","Retiring","Front-End Bound","Bad Speculation","Back-End Bound"
"1","/*","","","","","","",""
"2"," * Code for simulations","","","","","","",""
"3"," */","","","","","","",""
"4","","","","","","","",""
"5","// ReSharper disable CppTooWideScope","","","","","","",""
"6","// ReSharper disable CppTooWideScopeInitStatement","","","","","","",""
"7","#include ""openVCB.hh""","","","","","","",""
"8","","","","","","","",""
"9","namespace openVCB {","","","","","","",""
"10","","","","","","","",""
"11","[[__gnu__::__hot__]]","","","","","","",""
"12","SimulationResult","","","","","","",""
"13","Project::tick(int const numTicks, int64_t const maxEvents)","","","","","","",""
"14","{","","","","","","",""
"15","      SimulationResult res{};","","","","","","",""
"16","","","","","","","",""
"17","      for (; res.numTicksProcessed < numTicks; ++res.numTicksProcessed)","190800000","280800000","0.679487","7.39033e-05","0.000594585","6.28175e-05","0"
"18","      {","","","","","","",""
"19","            if (res.numEventsProcessed > maxEvents)","","","","","","",""
"20","                  return res;","","","","","","",""
"21","","","","","","","",""
"22","            for (auto &[index, bp_logic] : breakpoints) {","54000000","72000000","0.75","7.39033e-06","0","1.24711e-05","0"
"23","                  auto const &state = states[index];","","","","","","",""
"24","                  if (state.logic != bp_logic) {","","","","","","",""
"25","                        bp_logic       = state.logic;","","","","","","",""
"26","                        res.breakpoint = true;","","","","","","",""
"27","                  }","","","","","","",""
"28","            }","","","","","","",""
"29","            if (res.breakpoint)","","","","","","",""
"30","                  return res;","","","","","","",""
"31","","","","","","","",""
"32","            for (auto const &[buffer, bufferSize, idx] : instrumentBuffers) {","79200000","327600000","0.241758","2.95613e-05","0","3.55658e-05","0"
"33","#ifdef OVCB_MT","","","","","","",""
"34","                  memmove(&buffer[tickNum % bufferSize], &states[idx], sizeof(InkState));","","","","","","",""
"35","#else","","","","","","",""
"36","                  buffer[tickNum % bufferSize] = states[idx];","1224000000","356400000","3.43434","0.000251271","0.00178375","0.000503003","0.000431713"
"37","#endif","","","","","","",""
"38","            }","","","","","","",""
"39","            ++tickNum;","0","0","0","0","0.00118917","0","0"
"40","","","","","","","",""
"41","            // VMem implementation.","","","","","","",""
"42","            if (vmem) {","","","","","","",""
"43","                  // Get current address","","","","","","",""
"44","                  uint32_t addr = 0;","","","","","","",""
"45","                  for (int k = 0; k < vmAddr.numBits; ++k)","514800000","1677600000","0.306867","0.000406468","0","0","8.63425e-05"
"46","                        addr |= static_cast<unsigned>(getOn(states[vmAddr.gids[k]].logic)) << k;","583200000","2390400000","0.243976","0.000243881","0","0","0.000302199"
"47","","","","","","","",""
"48","                  if (addr != lastVMemAddr) {","39600000","144000000","0.275","2.95613e-05","0","0","4.31713e-05"
"49","                        // Load address","","","","","","",""
"50","                        lastVMemAddr  = addr;","7200000","0","","7.39033e-06","0.00178375","2.77135e-06","0"
"51","#ifdef OVCB_BYTE_ORIENTED_VMEM","","","","","","",""
"52","                        // Clang compiles this down to a very tidy handful of instructions.","","","","","","",""
"53","                        // In fact, it did better than I did writing assembly by hand.","","","","","","",""
"54","                        uint32_t data = (vmem.b[addr]) | (vmem.b[addr+1]<<8) | (vmem.b[addr+2]<<16) | (vmem.b[addr+3]<<24);","","","","","","",""
"55","#else","","","","","","",""
"56","                        uint32_t data = vmem.i[addr];","54000000","0","","7.39033e-06","0","1.80138e-05","0"
"57","#endif","","","","","","",""
"58","","","","","","","",""
"59","                        // Turn on those latches","","","","","","",""
"60","                        for (int k = 0; k < vmData.numBits; ++k) {","39600000","46800000","0.846154","7.39033e-06","0.000594585","3.41802e-05","0"
"61","                              auto      &state = states[vmData.gids[k]];","43200000","234000000","0.184615","5.17323e-05","0","0","0"
"62","                              bool const isOn  = getOn(state.logic);","","","","","","",""
"63","","","","","","","",""
"64","                              if (((data >> k) & 1) != isOn) {","86400000","165600000","0.521739","5.17323e-05","0.00178375","5.49653e-05","0"
"65","                                    state.activeInputs = 1;","122400000","14400000","8.5","2.95613e-05","0.000594585","5.08081e-05","0"
"66","                                    if (state.visited)","43200000","18000000","2.4","1.47807e-05","0","1.93995e-05","0"
"67","                                          continue;","","","","","","",""
"68","                                    state.visited       = true;","","","","","","",""
"69","                                    updateQ[0][qSize++] = vmData.gids[k];","25200000","61200000","0.411765","0","0.000594585","2.63279e-05","0"
"70","                              }","","","","","","",""
"71","                        }","","","","","","",""
"72","","","","","","","",""
"73","                        // Forcibly ignore further address updates","","","","","","",""
"74","                        for (int k = 0; k < vmAddr.numBits; ++k)","10800000","28800000","0.375","7.39033e-06","0.000594585","1.01616e-05","0"
"75","                              states[vmAddr.gids[k]].activeInputs = 0;","165600000","46800000","3.53846","2.2171e-05","0.00535126","1.52422e-05","0"
"76","                  } else {","","","","","","",""
"77","                        // Write address","","","","","","",""
"78","                        uint32_t data = 0;","","","","","","",""
"79","                        for (int k = 0; k < vmData.numBits; ++k) {","432000000","1281600000","0.337079","0.000384297","0.000594585","6.42026e-05","0"
"80","                              auto const &state = states[vmData.gids[k]];","190800000","316800000","0.602273","0.000147807","0","2.9099e-05","0"
"81","                              data |= static_cast<unsigned>(getOn(state.logic)) << k;","864000000","2314800000","0.37325","0.000812936","0.000594585","0","0.000259028"
"82","                        }","","","","","","",""
"83","","","","","","","",""
"84","#ifdef OVCB_BYTE_ORIENTED_VMEM","","","","","","",""
"85","                        auto *const tmp_ptr = vmem.word_at_byte(addr);","","","","","","",""
"86","                        *tmp_ptr = data | ((~UINT32_C(0) << vmData.numBits) & *tmp_ptr);","","","","","","",""
"87","#else","","","","","","",""
"88","                        vmem.i[addr] = data;","36000000","79200000","0.454545","7.39033e-05","0","0","0"
"89","#endif","","","","","","",""
"90","                  }","","","","","","",""
"91","            }","","","","","","",""
"92","","","","","","","",""
"93","            // Update the clock ink","","","","","","",""
"94","            if (++clockCounter >= clockPeriod)","39600000","79200000","0.5","7.39033e-06","0","5.21941e-05","0"
"95","                  clockCounter = 0;","10800000","7200000","1.5","0","0.00178375","1.33949e-05","0"
"96","            if (clockCounter < 2)","14400000","61200000","0.235294","7.39033e-06","0","0","4.31713e-05"
"97","                  for (auto const gid : clockGIDs)","144000000","104400000","1.37931","2.95613e-05","0","8.86837e-05","0"
"98","                        if (!states[gid].visited)","82800000","68400000","1.21053","3.69516e-05","0","6.83604e-05","4.31713e-05"
"99","                              updateQ[0][qSize++] = gid;","97200000","306000000","0.317647","1.47807e-05","0","8.77599e-05","0"
"100","","","","","","","",""
"101","            for (int traceUpdate = 0; traceUpdate < 2; ++traceUpdate) {","79200000","306000000","0.258824","2.2171e-05","0","4.06466e-05","0"
"102","                  // We update twice per tick","","","","","","",""
"103","                  // Remember stuff","","","","","","",""
"104","                  int const numEvents = qSize;","54000000","100800000","0.535714","2.95613e-05","0","5.08084e-05","0"
"105","                  qSize = 0;","28800000","144000000","0.2","1.47807e-05","0","2.67899e-05","0"
"106","                  res.numEventsProcessed += numEvents;","392400000","176400000","2.22449","0.000125636","0.00178375","0.000246651","0"
"107","","","","","","","",""
"108","                  // Copy over the current number of active inputs","","","","","","",""
"109","                  for (int i = 0; i < numEvents; ++i) {","378000000","748800000","0.504808","0.00022171","0.00535126","5.49649e-05","0.000129514"
"110","                        int const   gid = updateQ[0][i];","626400000","313200000","2","0.000192148","0.00118917","0.000372286","0.000259028"
"111","                        Logic const ink = states[gid].logic;","3600000","0","","0","0","0","0"
"112","","","","","","","",""
"113","                        // Reset visited flag","","","","","","",""
"114","                        states[gid].visited = false;","15206400000","74714400000","0.203527","0.0130218","0","0","0.00621666"
"115","","","","","","","",""
"116","                        // Copy over last active inputs","","","","","","",""
"117","                        lastActiveInputs[i] = states[gid].activeInputs;","16725600000","44460000000","0.376194","0.00577924","0.00237834","0.00838707","0.00479201"
"118","                        if (bool(ink & Logic::LatchOff))","43992000000","105040800000","0.418809","0.0351114","0.00416209","0","0.0142465"
"119","                              states[gid].activeInputs = 0;","428400000","144000000","2.975","0.000140416","0.00356751","0.000478522","0"
"120","                  }","","","","","","",""
"121","","","","","","","",""
"122","#ifdef OVCB_MT","","","","","","",""
"123","# pragma omp parallel for schedule(static, 4 * 1024) num_threads(2) if (numEvents > 8 * 1024)","","","","","","",""
"124","#endif","","","","","","",""
"125","                  // Main update loop","","","","","","",""
"126","                  for (int i = 0; i < numEvents; ++i) {","8852400000","4939200000","1.79227","0.0032887","0.00237834","0.00333625","0.00138148"
"127","                        int const   gid        = updateQ[0][i];","33886800000","148276800000","0.228537","0.0197174","0.00178375","0.0100776","0.00263345"
"128","                        Logic const curInk     = states[gid].logic;","","","","","","",""
"129","                        bool const  lastActive = getOn(curInk);","","","","","","",""
"130","                        int const   lastInputs = lastActiveInputs[i];","75088800000","263275200000","0.28521","0.0452436","0","0.0223838","0.00397176"
"131","                        bool        nextActive = false;","","","","","","",""
"132","","","","","","","",""
"133","                        Logic const offInk = setOff(curInk);","","","","","","",""
"134","                        switch (offInk) {","17661600000","11599200000","1.52266","0.00407946","0","0.0112199","0.000302199"
"135","                        case Logic::NonZeroOff:","","","","","","",""
"136","                              nextActive = lastInputs != 0;","19314000000","46566000000","0.414766","0.0107677","0.00178375","0.00532654","0.00125197"
"137","                              break;","","","","","","",""
"138","","","","","","","",""
"139","                        case Logic::ZeroOff:","","","","","","",""
"140","                              nextActive = lastInputs == 0;","14428800000","32158800000","0.448673","0.00786331","0.00297292","0.00237597","0.00185636"
"141","                              break;","","","","","","",""
"142","","","","","","","",""
"143","                        case Logic::XorOff:","","","","","","",""
"144","                              nextActive = lastInputs % 2;","6580800000","7016400000","0.937917","0.00349562","0.00178375","0.00199768","0.000992939"
"145","                              break;","","","","","","",""
"146","","","","","","","",""
"147","                        case Logic::XnorOff:","","","","","","",""
"148","                              nextActive = !(lastInputs % 2);","1004400000","936000000","1.07308","0.000436029","0","0.00029284","0.000302199"
"149","                              break;","","","","","","",""
"150","","","","","","","",""
"151","                        case Logic::LatchOff:","","","","","","",""
"152","                              nextActive = int(lastActive) ^ (lastInputs % 2);","964800000","500400000","1.92806","0.000273442","0.00118917","0.000520092","0.000172685"
"153","                              break;","","","","","","",""
"154","","","","","","","",""
"155","                        case Logic::ClockOff:","","","","","","",""
"156","                              nextActive = clockCounter == 0;","410400000","133200000","3.08108","7.39033e-05","0.00237834","0.000500232","0"
"157","                              break;","","","","","","",""
"158","","","","","","","",""
"159","                        default:;","","","","","","",""
"160","                        }","","","","","","",""
"161","","","","","","","",""
"162","                        // Short circuit if the state didnt change","","","","","","",""
"163","                        if (lastActive == nextActive)","2170800000","5205600000","0.417012","0.00109377","0","0.00114365","4.31713e-05"
"164","                              continue;","","","","","","",""
"165","","","","","","","",""
"166","                        // Update the state","","","","","","",""
"167","                        states[gid].logic = setOn(curInk, nextActive);","30769200000","111852000000","0.275089","0.0233313","0","0.00290111","0.00189954"
"168","","","","","","","",""
"169","                        // Loop over neighbors","","","","","","",""
"170","                        int const     delta = nextActive ? 1 : -1;","27669600000","139762800000","0.197975","0.021661","0.000594585","0.00102582","0.00189954"
"171","                        int32_t const end   = writeMap.ptr[gid + 1];","41284800000","118677600000","0.347874","0.0225922","0.00178375","0.0157787","0.00379907"
"172","                        int32_t       r     = writeMap.ptr[gid];","","","","","","",""
"173","","","","","","","",""
"174","                        for (r = writeMap.ptr[gid]; r < end; r++) {","106477200000","359686800000","0.296028","0.0629286","0.0184321","0.02452","0.00910914"
"175","                              int const   nxtId  = writeMap.rows[r];","70074000000","77104800000","0.908815","0.0286892","0.0683773","0.036394","0.00941134"
"176","                              Logic const nxtInk = setOff(states[nxtId].logic);","81360000000","32925600000","2.47103","0.025371","0","0.0594005","0.00915231"
"177","","","","","","","",""
"178","                              // Ignore falling edge for latches","","","","","","",""
"179","                              if (!nextActive && nxtInk == Logic::LatchOff) [[unlikely]]","5911200000","7844400000","0.753557","0.00192888","0","0.00464065","0.000561227"
"180","                                    continue;","","","","","","",""
"181","","","","","","","",""
"182","                              // Update actives","","","","","","",""
"183","#if defined OVCB_MT","","","","","","",""
"184","                              int const lastNxtInput = states[nxtId].activeInputs.fetch_add(delta, std::memory_order::relaxed);","","","","","","",""
"185","#else","","","","","","",""
"186","                              int const lastNxtInput     = states[nxtId].activeInputs;","48967200000","141026400000","0.34722","0.0247872","0","0.02043","0.0034537"
"187","                              states[nxtId].activeInputs = lastNxtInput + delta;","80859600000","255124800000","0.316941","0.0490053","0","0.0236683","0.00625983"
"188","#endif","","","","","","",""
"189","","","","","","","",""
"190","                              // Inks have convenient ""critical points""","","","","","","",""
"191","                              // We can skip any updates that do not hover around 0 with a few exceptions.","","","","","","",""
"192","                              if (lastNxtInput == 0 || lastNxtInput + delta == 0 ||","104194800000","341118000000","0.305451","0.0621379","0.0231888","0.0133703","0.0106201"
"193","                                  bool(nxtInk & (Logic::XorOff | Logic::XnorOff))) [[unlikely]]","","","","","","",""
"194","                                    tryEmit(nxtId);","","","","","","",""
"195","                        }","","","","","","",""
"196","                  }","","","","","","",""
"197","","","","","","","",""
"198","                  // Swap buffer","","","","","","",""
"199","                  std::swap(updateQ[0], updateQ[1]);","","","","","","",""
"200","            }","","","","","","",""
"201","      }","","","","","","",""
"202","","","","","","","",""
"203","      return res;","","","","","","",""
"204","}","0","0","0","0","0","2.30947e-06","0"
"205","","","","","","","",""
"206","void","","","","","","",""
"207","Project::addBreakpoint(int const gid)","","","","","","",""
"208","{","","","","","","",""
"209","      breakpoints[gid] = states[gid].logic;","","","","","","",""
"210","}","","","","","","",""
"211","","","","","","","",""
"212","void","","","","","","",""
"213","Project::removeBreakpoint(int const gid)","","","","","","",""
"214","{","","","","","","",""
"215","      breakpoints.erase(gid);","","","","","","",""
"216","}","","","","","","",""
"217","","","","","","","",""
"218","","","","","","","",""
"219","} // namespace openVCB","","","","","","",""
